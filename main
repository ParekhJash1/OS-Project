import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import os
from queue import Queue, Empty

# --- Project Modules ---
from print_job import PrintJob
from printer import Printer
from job_manager import JobManager
from scanner_window import BluetoothScanner

# --- Attempt to import PyPDF2 for PDF page counting ---
try:
    import PyPDF2
    PYPDF2_AVAILABLE = True
except ImportError:
    PYPDF2_AVAILABLE = False


# --- GUI Application ---
class PrinterApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Automatic Printer Scheduler") 
        self.geometry("1200x800") 
        self.resizable(True, True)
        
        self.themes = {
            "Light": {
                "BG_LIGHT": "#f8f9fa",
                "BG_WHITE": "#ffffff",
                "TEXT_DARK": "#212529",
                "TEXT_MUTED": "#555555",
                "BORDER_LIGHT": "#dee2e6",
                "PRIMARY_BLUE": "#007bff",
                "SUCCESS_GREEN": "#28a745",
                "WARN_ORANGE": "#fd7e14",
                "DANGER_RED": "#dc3545",
                "LOG_BG": "#e9e9e9",
                "TREE_SELECT_BG": "#cce5ff",
                "TREE_HEAD_BG": "#e9ecef"
            },
            "Dark": {
                "BG_LIGHT": "#212529",
                "BG_WHITE": "#343a40",
                "TEXT_DARK": "#f8f9fa",
                "TEXT_MUTED": "#adb5bd",
                "BORDER_LIGHT": "#495057",
                "PRIMARY_BLUE": "#0d6efd",
                "SUCCESS_GREEN": "#198754",
                "WARN_ORANGE": "#fd7e14",
                "DANGER_RED": "#dc3545",
                "LOG_BG": "#343a40",
                "TREE_SELECT_BG": "#0d6efd",
                "TREE_HEAD_BG": "#212529"
            }
        }
        
        self.update_queue = Queue() 
        self.job_manager = JobManager(self.update_queue)
        
        self.printers = {} # Store as {id: instance}
        self.printer_status_data = {} # Store as {id: status_dict}
        self.next_printer_id = 1

        self.set_theme("Light") 
        self.init_ui()

        self.process_updates()
        self.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        if not PYPDF2_AVAILABLE:
            self.log_message("WARNING: 'PyPDF2' not found. Install with 'pip install PyPDF2'.", "WARNING")
        else:
            self.log_message("INFO: 'PyPDF2' loaded successfully.", "INFO")
        
        # Add 1 printer by default
        self.add_printer("Default_Printer_1")

        self.queue_tree.bind('<<TreeviewSelect>>', self.update_button_states)
        self.printer_tree.bind('<<TreeviewSelect>>', self.update_button_states)

    def set_theme(self, theme_name):
        """Applies the selected color theme to the application."""
        theme = self.themes.get(theme_name, "Light")
        
        self.BG_LIGHT = theme["BG_LIGHT"]
        self.BG_WHITE = theme["BG_WHITE"]
        self.TEXT_DARK = theme["TEXT_DARK"]
        self.TEXT_MUTED = theme["TEXT_MUTED"]
        self.BORDER_LIGHT = theme["BORDER_LIGHT"]
        self.PRIMARY_BLUE = theme["PRIMARY_BLUE"]
        self.SUCCESS_GREEN = theme["SUCCESS_GREEN"]
        self.WARN_ORANGE = theme["WARN_ORANGE"]
        self.DANGER_RED = theme["DANGER_RED"]
        self.LOG_BG = theme["LOG_BG"]
        self.TREE_SELECT_BG = theme["TREE_SELECT_BG"]
        self.TREE_HEAD_BG = theme["TREE_HEAD_BG"]

        self.style = ttk.Style(self)
        self.style.theme_use('clam')
        self.init_style()

        self.configure(background=self.BG_LIGHT)

        if hasattr(self, 'log_text'):
            self.log_text.config(background=self.LOG_BG, foreground=self.TEXT_DARK)
            self.log_text.tag_configure("ERROR", foreground=self.DANGER_RED)
            self.log_text.tag_configure("WARNING", foreground=self.WARN_ORANGE)
            self.log_text.tag_configure("INFO", foreground=self.SUCCESS_GREEN)
            self.log_text.tag_configure("HEADING", foreground=self.PRIMARY_BLUE, font=("Consolas", 9, "bold"))
            self.log_text.tag_configure("MUTED", foreground=self.TEXT_MUTED)
        
        if hasattr(self, 'queue_tree'):
            self.queue_tree.tag_configure("Queued", foreground=self.TEXT_MUTED)
            self.queue_tree.tag_configure("Queued (Preempted)", foreground=self.WARN_ORANGE, font=("Segoe UI", 10, 'italic'))
            self.queue_tree.tag_configure("Canceled", foreground=self.DANGER_RED, font=("Segoe UI", 10, 'italic'))
        
        if hasattr(self, 'printer_tree'):
            self.printer_tree.tag_configure("Idle", foreground=self.TEXT_MUTED)
            self.printer_tree.tag_configure("Printing", foreground=self.PRIMARY_BLUE, font=("Segoe UI", 10, 'bold'))
            self.printer_tree.tag_configure("Paused", foreground=self.WARN_ORANGE)
            self.printer_tree.tag_configure("Offline", foreground=self.DANGER_RED, font=("Segoe UI", 10, 'italic'))

    def init_style(self):
        self.style.configure(".", background=self.BG_LIGHT, foreground=self.TEXT_DARK, font=("Segoe UI", 10))
        self.style.configure("TFrame", background=self.BG_LIGHT)
        self.style.configure("TLabel", background=self.BG_LIGHT, foreground=self.TEXT_DARK)
        
        self.style.configure("Card.TFrame", 
                             background=self.BG_WHITE, 
                             borderwidth=1, 
                             relief="solid", 
                             bordercolor=self.BORDER_LIGHT)
        
        self.style.configure("Card.TLabel", 
                             background=self.BG_WHITE, 
                             foreground=self.PRIMARY_BLUE, 
                             font=("Segoe UI", 13, "bold"))
        
        self.style.configure("Inner.TLabel", background=self.BG_WHITE, foreground=self.TEXT_DARK)
        
        self.style.configure("TButton", 
                             font=("Segoe UI", 10, "bold"), 
                             padding=8,
                             background=self.PRIMARY_BLUE,
                             foreground="#ffffff", 
                             relief='flat',
                             borderwidth=0)
        self.style.map("TButton", 
                       background=[('active', '#0056b3'), ('hover', '#0069d9')],
                       relief=[('pressed', 'flat')])
        
        self.style.configure("Disabled.TButton",
                             background="#c0c0c0",
                             foreground="#808080")
        
        self.style.configure("Success.TButton", 
                             background=self.SUCCESS_GREEN,
                             foreground="#ffffff")
        self.style.map("Success.TButton", 
                       background=[('active', '#218838'), ('hover', '#218838')])
        
        self.style.configure("Warn.TButton", 
                             background=self.WARN_ORANGE,
                             foreground="#ffffff")
        self.style.map("Warn.TButton", 
                       background=[('active', '#d96c12'), ('hover', '#ff8d2d')])

        self.style.configure("Danger.TButton", 
                             background=self.DANGER_RED,
                             foreground="#ffffff")
        self.style.map("Danger.TButton", 
                       background=[('active', '#b02a2a'), ('hover', '#e74c3c')])
        
        self.style.configure("TEntry", 
                             fieldbackground=self.BG_WHITE, 
                             foreground=self.TEXT_DARK,
                             borderwidth=1, 
                             relief='solid', 
                             bordercolor=self.BORDER_LIGHT)
        
        self.style.configure("TSpinbox",
                             fieldbackground=self.BG_WHITE,
                             foreground=self.TEXT_DARK,
                             borderwidth=1,
                             relief='solid',
                             bordercolor=self.BORDER_LIGHT,
                             arrowcolor=self.PRIMARY_BLUE,
                             font=("Segoe UI", 10))
        
        self.style.configure("TCombobox",
                             fieldbackground=self.BG_WHITE,
                             foreground=self.TEXT_DARK,
                             borderwidth=1,
                             relief='solid',
                             bordercolor=self.BORDER_LIGHT,
                             arrowcolor=self.PRIMARY_BLUE)
        self.style.map('TCombobox', 
                       fieldbackground=[('readonly', self.BG_WHITE)],
                       selectbackground=[('readonly', self.BG_WHITE)],
                       selectforeground=[('readonly', self.TEXT_DARK)])

        
        self.style.configure("Treeview.Heading", 
                             background=self.TREE_HEAD_BG, 
                             foreground=self.TEXT_DARK, 
                             font=("Segoe UI", 10, "bold"), 
                             relief='flat', 
                             borderwidth=0)
        
        self.style.configure("Treeview", 
                             background=self.BG_WHITE, 
                             fieldbackground=self.BG_WHITE, 
                             foreground=self.TEXT_DARK,
                             rowheight=28)
        self.style.map("Treeview", 
                       background=[('selected', self.TREE_SELECT_BG)], 
                       foreground=[('selected', self.TEXT_DARK)])

        self.style.configure("StatusAlgo.TLabel", 
                             background=self.BG_WHITE, 
                             foreground=self.TEXT_MUTED, 
                             font=("Segoe UI", 10, "italic"))


    def init_ui(self):
        main_frame = ttk.Frame(self, padding="15", style="TFrame")
        main_frame.pack(fill=tk.BOTH, expand=True)
        main_frame.rowconfigure(1, weight=1) 
        main_frame.columnconfigure(0, weight=2) 
        main_frame.columnconfigure(1, weight=1) 

        config_card = ttk.Frame(main_frame, style="Card.TFrame", padding=15)
        config_card.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 15))
        
        ttk.Label(config_card, text="‚öôÔ∏è Scheduler Config", style="Card.TLabel").grid(row=0, column=0, columnspan=4, sticky="w", pady=(0, 10))
        
        # --- MODIFICATION: Button text and command reverted ---
        self.manage_printers_button = ttk.Button(config_card, text="Manage Printers...", command=self.open_bluetooth_scanner)
        self.manage_printers_button.grid(row=1, column=0, sticky="w", padx=5)

        self.printer_count_label = ttk.Label(config_card, text="Connected Printers: 1", style="Inner.TLabel")
        self.printer_count_label.grid(row=1, column=1, sticky="w", padx=5)
        
        self.algo_status_label = ttk.Label(config_card, text="Active Algorithm: FCFS", style="StatusAlgo.TLabel")
        self.algo_status_label.grid(row=1, column=2, sticky="w", padx=(20, 5))
        
        self.theme_var = tk.StringVar(value="Light")
        self.theme_combo = ttk.Combobox(config_card, textvariable=self.theme_var, values=["Light", "Dark"], width=7, state="readonly")
        self.theme_combo.grid(row=1, column=3, sticky="e", padx=(20, 5))
        self.theme_combo.bind("<<ComboboxSelected>>", lambda e: self.set_theme(self.theme_var.get()))

        config_card.columnconfigure(3, weight=1) 

        # --- Left Column (Unchanged) ---
        left_column = ttk.Frame(main_frame, style="TFrame")
        left_column.grid(row=1, column=0, sticky="nsew", padx=(0, 15))
        left_column.rowconfigure(1, weight=1)
        left_column.columnconfigure(0, weight=1)

        input_card = ttk.Frame(left_column, style="Card.TFrame", padding=15)
        input_card.grid(row=0, column=0, sticky="ew", pady=(0, 15))
        input_card.columnconfigure(1, weight=1)
        
        ttk.Label(input_card, text="‚ûï Add New Print Job", style="Card.TLabel").grid(row=0, column=0, columnspan=3, sticky="w", pady=(0, 10))
        ttk.Label(input_card, text="PDF File:", style="Inner.TLabel").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.file_path_var = tk.StringVar()
        self.file_path_entry = ttk.Entry(input_card, textvariable=self.file_path_var, state="readonly")
        self.file_path_entry.grid(row=1, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
        self.browse_button = ttk.Button(input_card, text="Browse...", command=self.select_pdf)
        self.browse_button.grid(row=1, column=3, padx=5, pady=5)
        ttk.Label(input_card, text="Pages:", style="Inner.TLabel").grid(row=2, column=0, padx=5, pady=5, sticky="w")
        self.pages_var = tk.StringVar()
        self.pages_entry = ttk.Entry(input_card, textvariable=self.pages_var, width=10)
        self.pages_entry.grid(row=2, column=1, padx=5, pady=5, sticky="w")
        self.add_job_button = ttk.Button(input_card, text="Add to Queue", command=self.add_job)
        self.add_job_button.grid(row=3, column=0, columnspan=4, padx=5, pady=(10, 0), ipady=5, sticky="ew")
        input_card.columnconfigure(1, weight=1)

        queue_card = ttk.Frame(left_column, style="Card.TFrame", padding=15)
        queue_card.grid(row=1, column=0, sticky="nsew")
        queue_card.rowconfigure(1, weight=1)
        queue_card.columnconfigure(0, weight=1)
        ttk.Label(queue_card, text="üìã Print Queue", style="Card.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 10))
        self.queue_tree = ttk.Treeview(queue_card, columns=("ID", "File", "Pages", "Remaining", "Status"), show="headings")
        self.queue_tree.heading("ID", text="ID")
        self.queue_tree.heading("File", text="File Name")
        self.queue_tree.heading("Pages", text="Pages")
        self.queue_tree.heading("Remaining", text="Left")
        self.queue_tree.heading("Status", text="Status")
        self.queue_tree.column("ID", width=70, anchor=tk.W, stretch=tk.NO)
        self.queue_tree.column("File", width=250, anchor=tk.W, stretch=tk.YES)
        self.queue_tree.column("Pages", width=60, anchor=tk.CENTER, stretch=tk.NO)
        self.queue_tree.column("Remaining", width=60, anchor=tk.CENTER, stretch=tk.NO)
        self.queue_tree.column("Status", width=100, anchor=tk.W, stretch=tk.NO)
        self.queue_tree.grid(row=1, column=0, sticky="nsew")

        # --- Right Column ---
        right_column = ttk.Frame(main_frame, style="TFrame")
        right_column.grid(row=1, column=1, sticky="nsew")
        right_column.rowconfigure(0, weight=1) 
        right_column.rowconfigure(2, weight=1) 
        right_column.columnconfigure(0, weight=1)

        printer_status_card = ttk.Frame(right_column, style="Card.TFrame", padding=15)
        printer_status_card.grid(row=0, column=0, sticky="nsew", pady=(0, 15))
        printer_status_card.rowconfigure(1, weight=1)
        printer_status_card.columnconfigure(0, weight=1)
        ttk.Label(printer_status_card, text="üñ®Ô∏è Printer Status", style="Card.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 10))
        
        self.printer_tree = ttk.Treeview(printer_status_card, columns=("Name", "Status", "File", "Progress"), show="headings")
        self.printer_tree.heading("Name", text="Printer Name")
        self.printer_tree.heading("Status", text="Status")
        self.printer_tree.heading("File", text="File")
        self.printer_tree.heading("Progress", text="Progress")
        self.printer_tree.column("Name", width=120, anchor=tk.W, stretch=tk.YES)
        self.printer_tree.column("Status", width=80, anchor=tk.W, stretch=tk.NO)
        self.printer_tree.column("File", width=120, anchor=tk.W, stretch=tk.YES)
        self.printer_tree.column("Progress", width=100, anchor=tk.W, stretch=tk.NO)
        self.printer_tree.grid(row=1, column=0, sticky="nsew")

        controls_card = ttk.Frame(right_column, style="Card.TFrame", padding=15)
        controls_card.grid(row=1, column=0, sticky="ew", pady=(0, 15))
        ttk.Label(controls_card, text="Controls", style="Card.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 10))
        self.pause_button = ttk.Button(controls_card, text="‚è∏Ô∏è Pause Selected Printer", command=self.pause_printer, style="Warn.TButton")
        self.pause_button.grid(row=2, column=0, sticky="ew", pady=5, padx=5)
        self.cancel_button = ttk.Button(controls_card, text="‚ùå Cancel Selected Job", command=self.cancel_job, style="Danger.TButton")
        self.cancel_button.grid(row=3, column=0, sticky="ew", pady=5, padx=5)
        controls_card.columnconfigure(0, weight=1)

        log_card = ttk.Frame(right_column, style="Card.TFrame", padding=15)
        log_card.grid(row=2, column=0, sticky="nsew")
        log_card.rowconfigure(1, weight=1)
        log_card.columnconfigure(0, weight=1)
        ttk.Label(log_card, text="üìú Event Log", style="Card.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 10))
        self.log_text = tk.Text(log_card, font=("Consolas", 9), borderwidth=0, highlightthickness=0, state="disabled", wrap="word")
        self.log_text.grid(row=1, column=0, sticky="nsew")
        
        self.set_theme(self.theme_var.get()) 
        self.update_button_states()


    def log_message(self, message, tag=None):
        """Helper to insert messages into the log Text widget."""
        self.log_text.config(state="normal")
        
        if not tag:
            if "ERROR" in message: tag = "ERROR"
            elif "WARNING" in message: tag = "WARNING"
            elif "INFO" in message: tag = "INFO"
            elif "---" in message: tag = "HEADING"
            elif "Shutting down" in message: tag = "WARNING"
            elif "Offline" in message: tag = "ERROR"
            else: tag = "MUTED" 
        
        self.log_text.insert(tk.END, message + "\n", tag)
        self.log_text.config(state="disabled")
        self.log_text.see(tk.END)


    # --- MODIFICATION: Renamed function ---
    def open_bluetooth_scanner(self):
        """Opens the simulated scanner window."""
        connected_printers = {pid: p.printer_name for pid, p in self.printers.items()}
        # --- MODIFICATION: Call reverted class name ---
        scanner_window = BluetoothScanner(self, connected_printers)
        self.wait_window(scanner_window) 

    def add_printer(self, printer_name):
        """Adds a new printer to the system."""
        printer_id = self.next_printer_id
        self.next_printer_id += 1
        
        self.log_message(f"INFO: Connecting to '{printer_name}' (ID: {printer_id})...", "INFO")
        printer = Printer(printer_id, printer_name, self.job_manager, self.update_queue)
        self.printers[printer_id] = printer
        self.job_manager.add_printer(printer)
        printer.start()
        
        self.update_printers_display()
        self.printer_count_label.config(text=f"Connected Printers: {len(self.printers)}")
        return printer_id # Return new ID
    
    def remove_printer(self, printer_id):
        """Removes a printer from the system."""
        if printer_id in self.printers:
            printer_to_remove = self.printers.pop(printer_id)
            self.job_manager.remove_printer(printer_id)
            
            if printer_id in self.printer_status_data:
                del self.printer_status_data[printer_id]
                
            self.update_printers_display()
            self.printer_count_label.config(text=f"Connected Printers: {len(self.printers)}")
        else:
            self.log_message(f"WARNING: Tried to remove non-existent printer ID {printer_id}", "WARNING")
            
    # --- (End of new functions) ---


    def select_pdf(self):
        filepaths = filedialog.askopenfilenames(
            title="Select one or more PDF files",
            filetypes=(("PDF Files", "*.pdf"), ("All files", "*.*"))
        )
        if not filepaths:
            return
        
        if len(filepaths) > 1:
            if not PYPDF2_AVAILABLE:
                messagebox.showerror("Feature Disabled", "Install PyPDF2 for batch adding.")
                return
            
            jobs_added_count = 0
            for filepath in filepaths:
                file_name = os.path.basename(filepath)
                try:
                    with open(filepath, "rb") as f:
                        reader = PyPDF2.PdfReader(f)
                        pages = len(reader.pages)
                        if pages <= 0: raise ValueError("0 pages")
                    job = PrintJob(file_name, filepath, pages)
                    self.job_manager.add_job_to_queue(job) 
                    jobs_added_count += 1
                except Exception as e:
                    self.log_message(f"ERROR: Failed to add {file_name}: {e}", "ERROR")
            if jobs_added_count > 0:
                self.log_message(f"--- Added {jobs_added_count} jobs to queue. ---", "HEADING")
            
            self.file_path_var.set("")
            self.pages_var.set("")

        elif len(filepaths) == 1:
            filepath = filepaths[0]
            self.file_path_var.set(filepath)
            self.pages_entry.config(state="normal") 

            if PYPDF2_AVAILABLE:
                try:
                    with open(filepath, "rb") as f:
                        reader = PyPDF2.PdfReader(f)
                        self.pages_var.set(str(len(reader.pages)))
                except Exception as e:
                    self.pages_var.set("")
                    self.log_message(f"ERROR: Could not read PDF pages. Please enter manually.", "ERROR")
            else:
                self.pages_var.set("")

    def add_job(self):
        filepath = self.file_path_var.get()
        pages_str = self.pages_var.get()

        if not filepath and not pages_str:
            return 
        
        try:
            pages = int(pages_str)
            if not filepath or pages <= 0:
                raise ValueError("Invalid input")
        except ValueError:
            messagebox.showerror("Invalid Input", "Please select a file and enter a valid positive number for pages.")
            return
        
        job = PrintJob(os.path.basename(filepath), filepath, pages)
        self.job_manager.add_job_to_queue(job) 

        self.file_path_var.set("")
        self.pages_var.set("")
        self.pages_entry.config(state="normal") 
        self.queue_tree.focus_set() 


    def pause_printer(self):
        """Pauses the printer selected in the printer status treeview."""
        selected_items = self.printer_tree.selection()
        if not selected_items: return
        
        printer_id = selected_items[0]
        try:
            printer_id = int(printer_id)
        except (ValueError, IndexError):
            return 
        
        printer_to_pause = self.printers.get(printer_id)
        if printer_to_pause:
            printer_to_pause.toggle_pause()

    def cancel_job(self):
        """Cancels a job selected in EITHER treeview."""
        job_id_to_cancel = None
        
        selected_queue = self.queue_tree.selection()
        if selected_queue:
            try: job_id_to_cancel = self.queue_tree.item(selected_queue[0], "values")[0]
            except IndexError: pass 
        
        selected_printer = self.printer_tree.selection()
        if not job_id_to_cancel and selected_printer:
            try:
                printer_id = int(selected_printer[0])
                job_snapshot = self.printer_status_data.get(printer_id, {}).get('job')
                if job_snapshot: job_id_to_cancel = job_snapshot.job_id
            except (ValueError, IndexError): pass
        
        if not job_id_to_cancel: return
        
        if messagebox.askyesno("Confirm Cancel", f"Are you sure you want to cancel job {job_id_to_cancel}?"):
            self.job_manager.cancel_job(job_id_to_cancel)

    def update_button_states(self, event=None):
        """Enables/disables control buttons based on selection."""
        
        selected_printer_item = self.printer_tree.selection()
        selected_job_item = self.queue_tree.selection()

        if selected_printer_item:
            self.pause_button.config(state=tk.NORMAL, style="Warn.TButton")
        else:
            self.pause_button.config(state=tk.DISABLED, style="Disabled.TButton")

        if selected_printer_item or selected_job_item:
            self.cancel_button.config(state=tk.NORMAL, style="Danger.TButton")
        else:
            self.cancel_button.config(state=tk.DISABLED, style="Disabled.TButton")

    def process_updates(self):
        """Continuously checks the queue for updates from worker threads."""
        try:
            while True:
                command, data = self.update_queue.get_nowait()
                
                if command == 'log':
                    self.log_message(data)
                
                elif command == 'algorithm':
                    self.algo_status_label.config(text=f"Active Algorithm: {data}")
                
                elif command == 'update_queue':
                    self.update_queue_display(data)
                
                elif command == 'printer_status':
                    printer_info = data
                    printer_id = printer_info['id']
                    
                    if printer_info['status'] == "Offline":
                        # Handle offline printer removal
                        if printer_id in self.printers:
                            # This was a graceful shutdown
                            self.log_message(f"INFO: Printer '{printer_info['name']}' is now offline.", "INFO")
                            self.printers.pop(printer_id)
                            self.printer_count_label.config(text=f"Connected Printers: {len(self.printers)}")
                        if printer_id in self.printer_status_data:
                            self.printer_status_data.pop(printer_id)
                    else:
                        # Update status for an online printer
                        self.printer_status_data[printer_id] = printer_info
                    
                    self.update_printers_display()

        except Empty:
            pass # No updates
        finally:
            self.after(100, self.process_updates)

    def update_queue_display(self, queue_snapshot):
        """Refreshes the Queue Treeview with the current queue state."""
        selected_item = self.queue_tree.selection()
        
        self.queue_tree.delete(*self.queue_tree.get_children())
        for job in queue_snapshot:
            self.queue_tree.insert("", "end", iid=job.job_id, values=(
                job.job_id, job.file_name, job.pages, job.pages_remaining, job.status
            ), tags=(job.status,))
        
        if selected_item and self.queue_tree.exists(selected_item[0]):
            self.queue_tree.selection_set(selected_item[0])
            self.queue_tree.focus(selected_item[0])
        
        self.update_button_states() 

    def update_printers_display(self):
        """Refreshes the Printer Status Treeview."""
        selected_item = self.printer_tree.selection()

        self.printer_tree.delete(*self.printer_tree.get_children())
        
        for printer_id, printer_info in sorted(self.printer_status_data.items()):
            
            job = printer_info.get('job')
            status_str, file_str, progress_str = "Idle", "---", "---"
            
            if job:
                status_str = job.status
                file_str = job.file_name
                if job.pages > 0:
                    percent = (job.progress / job.pages) * 100
                    progress_str = f"{job.progress}/{job.pages} ({percent:.0f}%)"
                else:
                    progress_str = f"{job.progress}/{job.pages}"
            else:
                status_str = printer_info.get('status', 'Idle')
                if status_str != "Offline": status_str = "Idle" 

            self.printer_tree.insert("", "end", iid=printer_id, values=(
                printer_info['name'], status_str, file_str, progress_str
            ), tags=(status_str,))

        if selected_item and self.printer_tree.exists(selected_item[0]):
            self.printer_tree.selection_set(selected_item[0])
            self.printer_tree.focus(selected_item[0])

        self.update_button_states() 

    def on_closing(self):
        """Handles the window close event."""
        if messagebox.askokcancel("Quit", "Do you want to quit? This will stop all printing operations."):
            self.log_message("--- Shutting down all printers... ---", "HEADING")
            printer_ids = list(self.printers.keys())
            for pid in printer_ids:
                self.remove_printer(pid)
            
            self.after(500, self.destroy)
